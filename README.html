<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/default.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
<link rel="stylesheet" href="file:////home/tuco/.vscode-server/extensions/goessner.mdmath-2.7.4/themes/default/style.css">

</head>
<body class="markdown-body">
<div  ></div>
<div style="padding: 2% 5%;">
<div  ></div>
<h1 style="text-align: center;">
<div style="color:grey; font-size: 0.6em;">Jakub Ostrzołek</div>
<div>WSI ćwiczenie 3 - algorytm minimax z obcinaniem alpha - beta</div>
</h1>
<h2 id="opis-c487wiczenia">Opis ćwiczenia</h2>
<p>Celem ćwiczenia było zaimplementowanie algorytmu minimax z obcinaniem alpha - beta oraz przetestowanie go na <a href="https://github.com/lychanl/two-player-games">implementacji gry dots and boxes</a>.</p>
<p>Funkcja implementująca algorytm przyjmuje następujące główne argumenty:</p>
<ul>
<li><code>state</code> - stan gry, na podstawie którego wybierany jest następny ruch obecnego gracza</li>
<li><code>depth</code> - głębokość przeszukiwania drzewa stanów gry</li>
<li><code>evaluate_state</code> - funkcja ewaluująca stan gry (dodatnie wartości oznaczają przewagę gracza max, ujemne - min)</li>
<li><code>max_player</code> - wybór gracza max</li>
</ul>
<p>Funkcja zwraca krotkę <code>(ocena, ruch)</code>, która reprezentuje najlepsze rozwiązanie dla gracza max.</p>
<h2 id="wykorzystane-zewnc499trzne-biblioteki">Wykorzystane zewnętrzne biblioteki</h2>
<ul>
<li><code>numpy</code></li>
<li><code>matplotlib</code></li>
<li><code>pytest</code></li>
<li><code>pytest-benchmark</code></li>
</ul>
<h2 id="uc5bcycie">Użycie</h2>
<p>Aby użyć algorytmu dla wybranych parametrów algorytmu należy uruchomić skrypt <code>main.py</code> i postępować zgodnie z instrukcjami (<code>main.py --help</code>).</p>
<h2 id="przeprowadzenie-rozgrywek">Przeprowadzenie rozgrywek</h2>
<p>Rozgrywki należy uruchomić komendą <code>pytest --benchmark-json=benchmark.json</code>.</p>
<h2 id="wykresy">Wykresy</h2>
<p>Aby wygenerować wykresy, należy wykonać skrypt <code>plot.py</code>. Za pomocą skryptu można wygenerować:</p>
<ul>
<li>wykresy przebiegu jednej rozgrywki, z oznaczonymi ocenami ruchów graczy oraz ich punktami w każdej turze gry</li>
<li>wykresy porównujące końcowe wyniki pierwszego i drugiego gracza w zależności od zmieniającej się głębokości przeszukiwania drugiego gracza, przy stałym rozmiarze planszy i głębokości przeszukiwania pierwszego gracza.</li>
</ul>
<p>Oto przykładowe wyniki:</p>
<ul>
<li>Przebiegi rozgrywek:</li>
</ul>
<p><img src="plots/progress/size=2,p1_depth=6,p2_depth=4.jpg" alt="wykres" class="loading" id="image-hash--1542186812" data-src="plots/progress/size=2,p1_depth=6,p2_depth=4.jpg">
<img src="plots/progress/size=2,p1_depth=6,p2_depth=8.jpg" alt="wykres" class="loading" id="image-hash--1538492728" data-src="plots/progress/size=2,p1_depth=6,p2_depth=8.jpg">
<img src="plots/progress/size=3,p1_depth=4,p2_depth=2.jpg" alt="wykres" class="loading" id="image-hash-438648517" data-src="plots/progress/size=3,p1_depth=4,p2_depth=2.jpg">
<img src="plots/progress/size=3,p1_depth=4,p2_depth=6.jpg" alt="wykres" class="loading" id="image-hash-442342601" data-src="plots/progress/size=3,p1_depth=4,p2_depth=6.jpg">
<img src="plots/progress/size=4,p1_depth=3,p2_depth=2.jpg" alt="wykres" class="loading" id="image-hash-1910796711" data-src="plots/progress/size=4,p1_depth=3,p2_depth=2.jpg">
<img src="plots/progress/size=4,p1_depth=3,p2_depth=4.jpg" alt="wykres" class="loading" id="image-hash-1912643753" data-src="plots/progress/size=4,p1_depth=3,p2_depth=4.jpg">
<img src="plots/progress/size=5,p1_depth=2,p2_depth=1.jpg" alt="wykres" class="loading" id="image-hash--912945912" data-src="plots/progress/size=5,p1_depth=2,p2_depth=1.jpg">
<img src="plots/progress/size=5,p1_depth=2,p2_depth=3.jpg" alt="wykres" class="loading" id="image-hash--911098870" data-src="plots/progress/size=5,p1_depth=2,p2_depth=3.jpg"></p>
<ul>
<li>Porównania:</li>
</ul>
<p><img src="plots/compare/size=2,p1_depth=6.jpg" alt="wykres" class="loading" id="image-hash--708342633" data-src="plots/compare/size=2,p1_depth=6.jpg">
<img src="plots/compare/size=3,p1_depth=4.jpg" alt="wykres" class="loading" id="image-hash--1220723852" data-src="plots/compare/size=3,p1_depth=4.jpg">
<img src="plots/compare/size=4,p1_depth=3.jpg" alt="wykres" class="loading" id="image-hash--1732181550" data-src="plots/compare/size=4,p1_depth=3.jpg">
<img src="plots/compare/size=5,p1_depth=2.jpg" alt="wykres" class="loading" id="image-hash-2051328048" data-src="plots/compare/size=5,p1_depth=2.jpg"></p>
<h2 id="wnioski">Wnioski</h2>
<p>Z wykresów przebiegu rozgrywki można zauważyć, że:</p>
<ul>
<li>przez ok. połowę gry gracze nie są w stane przewidzieć dobrych ruchów, wybierają ruchy w których nie stracą w bezpośredni sposób punktów, przez co wyniki utrzymują się przy zerze. Gracze 'boją się' wykonać ryzykowny ruch, który może opłacić się później, bo nie potrafią przwidzieć tak dalekiej przyszłości.</li>
<li>w pewnym momencie jeden z graczy znajduje dobrą strategię wygrywającą, lub 'orientuje się', że prawdopodobnie jest na przegranej pozycji. Zazwyczaj ten stan rzeczy utrzymuje się do końca - wygrywający wygrywa, a przegrywający przegrywa.</li>
<li>zazwyczaj jako pierwszy jest w stanie ocenić swój ruch na wartość różną od 0 gracz o większej głębokości przeszukiwania, jednak nie zawsze oznacza to, że on właśnie wygra.</li>
<li>gracze bardzo często zdobywają wiele punktów z rzędu - prowadzi to do &quot;schodkowgo&quot; wyglądu wykresów. Im większy <code>size</code>, tym bardziej jest to widoczne.</li>
</ul>
<p>Z wykresów porównujących można wywnioskować, że:</p>
<ul>
<li><code>size=2</code>:
<ul>
<li>pierwszy gracz ma dużą przewagę - wygrywa nawet, gdy drugi głębiej przeszkuje graf stanów</li>
</ul>
</li>
<li><code>size=3</code>:
<ul>
<li>pierwszy gracz ma lekką przewagę - gdy drugi gracz głębiej przeszukuje graf stanów od pierwszego, ma szansę go pokonać</li>
</ul>
</li>
<li><code>size=4</code>:
<ul>
<li>głębokość przeszukiwania ma mały wpływ na wynik rozgrywki - dla wybranych przeze mnie wartości mecz zawsze kończy się remisem. Niestety nie mogłem sobie pozwolić na ustawianie większego <code>p2_depth</code> niż 5, bo zbyt długo wykonywałby się benchmark (dla <code>p2_depth=5</code> już wykonywał się ponad 1 minutę). Natomiast mogłem zmniejszyć <code>p1_depth</code>. Jak widać na poniższym wykresie dalej utrzymuje się ten sam wynik meczu:<br>
<img src="plots/compare/size=4,p1_depth=1.jpg" alt="wykres" class="loading" id="image-hash--1734028592" data-src="plots/compare/size=4,p1_depth=1.jpg"></li>
</ul>
</li>
<li><code>size=5</code>
<ul>
<li>podobnie jak w przypadku <code>size=4</code> - nie widać wpływu <code>p2_depth</code> na wynik rozgrywki, nawet dla mniejszego <code>p1_depth</code>:<br>
<img src="plots/compare/size=5,p1_depth=1.jpg" alt="wykres" class="loading" id="image-hash-2050404527" data-src="plots/compare/size=5,p1_depth=1.jpg"></li>
<li>w odróżnieniu od przypadku <code>size=4</code>, tutaj zamiast remisu cały czas wygrywa gracz drugi przewagą 5 pkt.</li>
</ul>
</li>
</ul>
<p>Można zauważyć cieakawą zależność:</p>
<ul>
<li>dla <code>size=3</code> zazwyczaj wygrywa gracz 1. przewagą 3 pkt (równą <code>size</code>)</li>
<li>dla <code>size=4</code> remis</li>
<li>dla <code>size=5</code> wygrywa gracz 2. przewagą 5 pkt (równą <code>size</code>)</li>
</ul>
<p>Gdy obejrzymy przebieg przykładowej rogrywki dla dużych <code>size</code>, od razu wyjaśnia się powyższa zależność. Widać również powód równych wynków graczy niezależnie od wartości <code>p2_depth</code> oraz &quot;schodkowych&quot; wykresów.</p>
<p><img src="resources/big_size_game.gif" alt="gra" class="loading" id="image-hash-311027348" data-src="resources/big_size_game.gif"></p>
<p>Gracze na początku zapełniają planszę poziomymi kreskami. Następnie naprzemiennie zajmują całe rzędy kwadratów na raz - stąd &quot;schodki&quot;.
Równe wyniki można wyjaśnić tym, że po zapełnieniu planszy poziomymi kreskami, tak na prawdę nie mają znaczenia następne ruchy. Od tego momentu gra może mieć tylko dwa rozstrzygnięcia:</p>
<ul>
<li>jeżeli <code>size</code> jest parzyste - remis</li>
<li>jeżeli <code>size</code> jest nieparzyste - wygra gracz, który jako pierwszy zdobędzie punkty za zapełnienie jednego rzędu. Dokładniej:
<ul>
<li>dla <code>size=4n+1</code> wygra gracz 2.</li>
<li>dla <code>size=4n+3</code> wygra gracz 1.</li>
</ul>
</li>
</ul>
<p>Aby zapobiec tego typu zachowaniom, należałoby znacznie zwiększyć głębokość przeszukiwania grafów stanów dla graczy, dzięki czemu mogliby zareagować przed wystąpieniem &quot;punktu bez powrotu&quot; - czyli zapełnieniem wszystkich miejsc na poziome kreski. Niestety zwiększenie głębokości przeszukiwania wiąże się z wykładniczym wzrostem ilości wykonywanych obliczeń, co szybko prowadzi do ekstremalnie długich czasów przebiegu gry (przebiegi użyte w tej dokumentacji wykonywały się łącznie 37 minut).</p>
<div  ></div>
</div>
</body>
</html>